# 1장 객체, 설계

## Reference

- [오브젝트 - 조영호 저자(글)](https://product.kyobobook.co.kr/detail/S000001766367)

소프트웨어 모듈에는 세가지 목적이 있다.

- 첫 번째 목적은 실행 중에 제대로 동작하는 것이다.
- 두 번째 목적은 변경을 위해 존재하는 것이다.
- 세번째 목적은 코드를 읽는 사람과 의사소통하는 것이다.

하나의 클래스나 메서드에서 너무 많은 세부사항을 다루기 때문에 코드를 작성하는 사람뿐만 아니라 코드를 읽고 이해해야 하는 사람 모두에게 큰 부담을 준다.

## 변경에 취약한 코드

의존성이 변경에 관견되어 있다. 의존성이라는 말속에서는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포되어 있다. 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이다. 따라서 애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것이다. 객체간의 의존성이 과한 경우를 **결합도**가 높다고 말한다. 합리적인 수준의 의존성일 경우 결합도가 낮다 한다.

개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화라 부른다. 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다.

## 캡슐화와 응집도

밀접하게 연관도니 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 말한다. 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을 뿐더러 응집도를 높일 수 있다.

응집도를 높이기 위해서 객체 스스로 자신의 데이터를 책임져야 한다. 객체는 자신의 데이터를 스스로 처리하는 자율적인 존재여야 한다.

## 절차지향과 객체지향

절차적 프로그래밍의 세상에는 데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어렵다. 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍 하는 방식을 객체지향 프로그래밍이라고 부른다.

## 책임의 이동

각 객체는 자신을 스스로 책임진다. 객체지향 애플리케이션은 스스로 책임ㅇ르 수행하는 자율적인 객체들의 공동체를 구성함으로써 완성된다. 설계를 어렵게 하는 것은 의존성이다. 불필요한 의존성을 제거함으로써 객체 사이의 결합도를 낮추는 것이다. 세부사항을 내부로 감춰 캡슐화하는 것이다. 불필요한 세부사항을 객체 내부로 캡슐화하느 것은 객체의 자율성을 높이고 응집도 높은 객체들의 공동체를 창조할 수 있게한다.

객체는 무생물이나 심지어는 실세계의 개념적인 개체로 모델링될 수 있지만, 그들은 마치 우리가 현실세계에서 에이전트로 행동하는 것처럼 그들의 시스템 안에 에이전트처럼 행동한다. 의인화의 관점에서 소프트웨어를 생물로 생각하자. 모든 생물처럼 소프트웨어는 태어나고, 삶을 영위하고, 그리고 죽는다.

훌륭한 객체지향 설계란 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계를 가리킨다. 그 대상이 비록 실세계에서는 생명이 없는 수동적인 존재여도, 객체지향의 세계에서는 그들은 생명과 지능을 가진 싱싱한 존재로 다시 태어난다.

## 설계가 왜 필요한가

설계가 코드를 작성하는 것보다는 높은 차원의 창조적인 행위가 아니다. 설계는 코드를 작성하는 매 순간 코드를 어떻게 배치할 것인지를 결정하는 과정에서 나온다. 설계는 코드 작성의 일부이다. 코드를 작성하지 않고서는 검증할 수 없다.

좋은 설계란 무엇인가? 오늘 완성해야하는 기능을 구현하는 코드를 짜야하는 동시에 내일 쉽게 변경할 수 있는 코드를 짜야한다. 변경을 수용할 수 있는 설계가 중요한 이유는 요구사항이 항상 변경되기 때문이다. 또 다른 이유는 코드를 변경할 때 버그가 추가될 가능성이 높기 때문이다. 요구사항은 코드를 변경시키고, 코드 변경은 버그를 발생시킨다.

## 객체지향 설계

우리가 원하는 것은 변경에 유연하게 대응하는 코드이다. 객체지향 프로그래밍은 의존성을 효율적으로 통제할 수 있는 다양한 방법을 제공하여 요구사항 변경에 좀 더 수월하게 대응할 수 있는 가능성을 높인다. 변경 가능한 코드란 이해하기 쉬운 코드이다. 데이터와 프로세스를 객체라는 덩어리 안에 넣었다고 해서 변경하기 쉬운 설계를 얻을 수 있는게 아니다. 객체들의 사이의 상호작용은 객체 사이에 주고 받는 메시지로 표현된다.